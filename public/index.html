<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GLOBAL THERMONUCLEAR CHAT</title>

  <!-- Leaflet map CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    :root {
      background-color: #000;
      color: #33ff66;
      font-family: "Courier New", monospace;

      --bg-color: #000;
      --primary: #33ff66;
      --secondary: #55ff88;
      --warn: #ff9933;
      --muted: #145f2a;
      --map-hue: 80deg;
    }

    body.defcon-theme-5 {
      --primary: #33ff66;
      --secondary: #55ff88;
      --warn: #ff9933;
      --muted: #145f2a;
      --map-hue: 80deg;
    }

    body.defcon-theme-4 {
      --primary: #7fff33;
      --secondary: #a2ff66;
      --warn: #ffb733;
      --muted: #3c661c;
      --map-hue: 60deg;
    }

    body.defcon-theme-3 {
      --primary: #ffff33;
      --secondary: #ffff7a;
      --warn: #ffb733;
      --muted: #666214;
      --map-hue: 40deg;
    }

    body.defcon-theme-2 {
      --primary: #ff9933;
      --secondary: #ffc266;
      --warn: #ff7a33;
      --muted: #663d14;
      --map-hue: 10deg;
    }

    body.defcon-theme-1 {
      --primary: #ff3333;
      --secondary: #ff6666;
      --warn: #ffcc66;
      --muted: #661414;
      --map-hue: -20deg;
    }

    * {
      box-sizing: border-box;
    }

    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: var(--bg-color);
      color: var(--primary);
      transition: color 0.3s ease, background-color 0.3s ease;
    }

    .crt-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(
        to bottom,
        rgba(0, 0, 0, 0.3) 0px,
        rgba(0, 0, 0, 0.3) 1px,
        rgba(0, 0, 0, 0.0) 3px,
        rgba(0, 0, 0, 0.0) 4px
      );
      mix-blend-mode: multiply;
      z-index: 10;
    }

    .frame {
      width: 90vw;
      height: 90vh;
      border: 1px solid var(--primary);
      padding: 8px;
      display: flex;
      flex-direction: column;
      background-color: var(--bg-color);
      position: relative;
      overflow: hidden;
      transition: border-color 0.3s ease, background-color 0.3s ease;
    }

    .header {
      border-bottom: 1px solid var(--primary);
      padding-bottom: 4px;
      margin-bottom: 4px;
      text-transform: uppercase;
      font-size: 12px;
      letter-spacing: 2px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
    }

    .header-title {
      margin: 0;
    }

    .header-right {
      font-size: 11px;
      text-align: right;
    }

    .defcon {
      font-weight: bold;
    }

    .defcon-level-5 { color: #33ff66; }
    .defcon-level-4 { color: #7fff33; }
    .defcon-level-3 { color: #ffff33; }
    .defcon-level-2 { color: #ff9933; }
    .defcon-level-1 { color: #ff3333; }

    .layout {
      flex: 1;
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 6px;
      height: 100%;
    }

    .panel {
      border: 1px solid var(--primary);
      display: flex;
      flex-direction: column;
      font-size: 12px;
      transition: border-color 0.3s ease;
    }

    .panel-title {
      border-bottom: 1px solid var(--primary);
      padding: 4px 6px;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: border-color 0.3s ease;
    }

    .panel-body {
      flex: 1;
      padding: 4px 6px;
      overflow-y: auto;
      white-space: pre-wrap;
    }

    .chat-line {
      margin-bottom: 2px;
    }

    .chat-line.system {
      color: var(--secondary);
    }

    .chat-line.warn {
      color: var(--warn);
    }

    .chat-meta {
      color: var(--secondary);
    }

    .chat-text {
      color: var(--primary);
    }

    .chat-input-row {
      border-top: 1px solid var(--primary);
      padding: 4px 6px;
      display: flex;
      align-items: center;
      gap: 4px;
      transition: border-color 0.3s ease;
    }

    .prompt {
      font-weight: bold;
    }

    #chat-input {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      color: var(--primary);
      font: inherit;
      transition: color 0.3s ease;
    }

    #chat-input::placeholder {
      color: var(--muted);
    }

    .cursor {
      display: inline-block;
      width: 8px;
      animation: blink 1s steps(1) infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    .footer-line {
      margin-top: 4px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 2px;
      opacity: 0.8;
    }

    /* Map look + CRT vibe */
    .map-container {
      width: 100%;
      height: 100%;
      border: 1px solid var(--primary);
      /* Softer green tint */
      filter:
        grayscale(1)
        sepia(1)
        hue-rotate(var(--map-hue))
        saturate(3)
        brightness(0.9)
        contrast(1.3);
      background: #000;
      position: relative;
      overflow: hidden;
      transition: border-color 0.3s ease, filter 0.3s ease;
    }

    .leaflet-container {
      background: #000 !important;
      font-family: "Courier New", monospace;
    }

    .leaflet-control-attribution,
    .leaflet-control-zoom {
      display: none !important;
    }

    /* Green glowing X marker */
    @keyframes pulse {
      0% { text-shadow: 0 0 4px var(--primary); }
      50% { text-shadow: 0 0 8px var(--primary); }
      100% { text-shadow: 0 0 4px var(--primary); }
    }

    .wargames-marker {
      color: var(--primary);
      font-size: 18px;
      line-height: 18px;
      transform: translate(-50%, -50%);
      animation: pulse 2s infinite;
    }

    /* Radar sweep overlay */
    #radar-sweep {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 160%;
      height: 160%;
      border-top: 1px solid var(--primary);
      border-radius: 50%;
      transform-origin: 0 0;
      pointer-events: none;
      mix-blend-mode: screen;
      animation: sweep 4s linear infinite;
      opacity: 0.45;
    }

    @keyframes sweep {
      0% {
        transform: rotate(0deg) translate(-50%, -50%);
      }
      100% {
        transform: rotate(360deg) translate(-50%, -50%);
      }
    }
  </style>
</head>
<body>
  <div class="crt-overlay"></div>

  <div class="frame">
    <div class="header">
      <div>
        <h1 class="header-title">NORAD MAINFRAME / GLOBAL THERMONUCLEAR CHAT</h1>
        <div>SYSTEM STATUS: ONLINE</div>
      </div>
      <div class="header-right">
        <div>SIMULATION CORE: WOPR/SCENARIO-ENGINE</div>
        <div id="defcon-display" class="defcon defcon-level-5">DEFCON: 5</div>
      </div>
    </div>

    <div class="layout">
      <!-- Chat / CLI panel -->
      <div class="panel">
        <div class="panel-title">TERMINAL LINK</div>
        <div id="chat-log" class="panel-body">
          INITIALIZING LINK...
        </div>
        <form id="chat-form" class="chat-input-row">
          <span class="prompt">&gt;</span>
          <input
            id="chat-input"
            type="text"
            autocomplete="off"
            placeholder="TYPE /HELP TO BEGIN..."
          />
          <span class="cursor">█</span>
        </form>
      </div>

      <!-- Right panel: map + status -->
      <div class="panel">
        <div class="panel-title">GLOBAL DISPLAY</div>
        <div class="panel-body" style="display: flex; flex-direction: column;">
          <div id="map" class="map-container">
            <!-- radar sweep overlay will be injected here -->
          </div>

          <div class="footer-line" id="status-line">
            ACTIVE LINKS: 00
          </div>
        </div>
      </div>
    </div>
  </div>

    <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Socket.io client script served from the Node server -->
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const chatLog = document.getElementById('chat-log');
    const chatForm = document.getElementById('chat-form');
    const chatInput = document.getElementById('chat-input');
    const statusLine = document.getElementById('status-line');
    const defconDisplay = document.getElementById('defcon-display');

    let currentDefconTheme = 5;

    let map;
    let markersLayer;
    let xIcon;

    // --- GAME STATE -----------------------------------------------------------
    let currentGame = null; // { start(), handleInput(text) }

    // --- UTIL: append lines ---------------------------------------------------
    function appendLine(text, kind = "normal") {
      const line = document.createElement('div');
      line.classList.add('chat-line');
      if (kind === 'system') line.classList.add('system');
      if (kind === 'warn') line.classList.add('warn');
      line.textContent = text;
      chatLog.appendChild(line);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    // --- DEFCON ---------------------------------------------------------------
    function setDefcon(level) {
      level = Math.min(5, Math.max(1, level));
      defconDisplay.textContent = 'DEFCON: ' + level;
      defconDisplay.className = 'defcon defcon-level-' + level;

      if (currentDefconTheme !== level) {
        document.body.classList.remove('defcon-theme-' + currentDefconTheme);
      }
      document.body.classList.add('defcon-theme-' + level);
      currentDefconTheme = level;
    }

    // --- MAP SETUP ------------------------------------------------------------
    function initMap() {
      if (map) return;

      map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        worldCopyJump: true
      }).setView([20, 0], 2);

      // Dark tiles, we tint them green via CSS filter
      L.tileLayer(
        'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png',
        {
          maxZoom: 6,
          minZoom: 1
        }
      ).addTo(map);

      markersLayer = L.layerGroup().addTo(map);

      // Neon green "X" icon
      xIcon = L.divIcon({
        className: 'wargames-marker',
        html: '✕',
        iconSize: [18, 18],
        iconAnchor: [9, 9]
      });

      // Radar sweep overlay
      const mapEl = document.getElementById('map');
      const sweep = document.createElement('div');
      sweep.id = 'radar-sweep';
      mapEl.appendChild(sweep);
    }

    function updateMarkers(users) {
      if (!map) initMap();
      markersLayer.clearLayers();

      const coords = [];

      users.forEach((u) => {
        if (typeof u.lat !== 'number' || typeof u.lon !== 'number') return;

        const lat = u.lat;
        const lon = u.lon;
        coords.push([lat, lon]);

        const label = `${u.codename || 'LINK'}\n${u.city || ''}${u.city && u.country ? ', ' : ''}${u.country || ''}`;

        const marker = L.marker([lat, lon], {
          icon: xIcon
        });

        marker.bindPopup(label.replace('\n', '<br/>'));
        markersLayer.addLayer(marker);
      });

      if (coords.length) {
        const bounds = L.latLngBounds(coords);
        map.fitBounds(bounds.pad(0.5));
      }
    }

    // --- BOOT SEQUENCE --------------------------------------------------------
    function runBootSequence() {
      const lines = [
        'NORAD MAINFRAME LINK ESTABLISHED.',
        'LOADING WOPR STRATEGIC SCENARIO ENGINE...',
        'SCANNING GLOBAL ROUTES........................OK',
        'AUTHENTICATING TERMINAL........................OK',
        'RESOLVING NODE LOCATION........................OK',
        '',
        'SYSTEM ONLINE.',
        ''
      ];

      let idx = 0;
      function next() {
        if (idx < lines.length) {
          appendLine(lines[idx], 'system');
          idx++;
          setTimeout(next, 400);
        } else {
          appendLine('TYPE /HELP TO LIST AVAILABLE COMMANDS.', 'system');
        }
      }
      next();
    }

    // --- TIC-TAC-TOE GAME -----------------------------------------------------
    function createTicTacToeGame() {
      let board;
      let gameOver;

      function reset() {
        board = Array(9).fill(null);
        gameOver = false;
      }

      function drawBoard() {
        const toChar = (i) => board[i] || (i + 1).toString();
        const rows = [
          ` ${toChar(0)} | ${toChar(1)} | ${toChar(2)} `,
          "---+---+---",
          ` ${toChar(3)} | ${toChar(4)} | ${toChar(5)} `,
          "---+---+---",
          ` ${toChar(6)} | ${toChar(7)} | ${toChar(8)} `,
        ];
        appendLine('');
        rows.forEach((r) => appendLine(r));
        appendLine('');
      }

      function checkWinner(b) {
        const lines = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8],
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8],
          [0, 4, 8],
          [2, 4, 6],
        ];
        for (const [a, c, d] of lines) {
          if (b[a] && b[a] === b[c] && b[a] === b[d]) return b[a];
        }
        if (b.every((cell) => cell)) return 'DRAW';
        return null;
      }

      function aiMove() {
        // simple AI: take first open spot
        for (let i = 0; i < 9; i++) {
          if (!board[i]) {
            board[i] = 'O';
            break;
          }
        }
      }

      function processMove(posStr) {
        const pos = parseInt(posStr, 10);
        if (Number.isNaN(pos) || pos < 1 || pos > 9) {
          appendLine('ENTER A POSITION 1-9.');
          return;
        }
        const idx = pos - 1;
        if (board[idx]) {
          appendLine('SQUARE ALREADY TAKEN.');
          return;
        }

        board[idx] = 'X';
        let result = checkWinner(board);
        drawBoard();
        if (result) {
          if (result === 'DRAW') appendLine('GAME RESULT: DRAW.');
          else appendLine(`WINNER: ${result}`);
          gameOver = true;
          appendLine('');
          appendLine('TYPE PLAY TO START AGAIN OR EXIT TO RETURN.');
          return;
        }

        // AI turn
        aiMove();
        result = checkWinner(board);
        drawBoard();
        if (result) {
          if (result === 'DRAW') appendLine('GAME RESULT: DRAW.');
          else appendLine(`WINNER: ${result}`);
          gameOver = true;
          appendLine('');
          appendLine('TYPE PLAY TO START AGAIN OR EXIT TO RETURN.');
          return;
        }
      }

      function start() {
        reset();
        appendLine('TIC-TAC-TOE', 'system');
        appendLine('', 'system');
        appendLine('YOU ARE X. COMPUTER IS O.', 'system');
        appendLine('ENTER A NUMBER (1-9) TO PLACE YOUR MARK.', 'system');
        appendLine('TYPE EXIT TO LEAVE THE GAME.', 'system');
        drawBoard();
      }

      function handleInput(raw) {
        const trimmed = raw.trim();
        const cmd = trimmed.toUpperCase();

        if (cmd === 'EXIT' || cmd === '/EXIT' || cmd === 'QUIT') {
          appendLine('EXITING TIC-TAC-TOE. RETURNING TO TERMINAL.', 'system');
          currentGame = null;
          return;
        }

        if (gameOver) {
          if (cmd === 'PLAY') {
            reset();
            drawBoard();
          } else {
            appendLine('GAME OVER. TYPE PLAY OR EXIT.');
          }
          return;
        }

        processMove(trimmed);
      }

      return { start, handleInput };
    }

    // --- CHESS ----------------------------------------------------------------
    function createChessGame() {
      const files = 'abcdefgh';
      const emptyRow = () => Array(8).fill(null);
      let board = [];
      let turn = 'W';
      let vsAI = true;
      let gameOver = false;

      function resetBoard() {
        board = [
          [
            { t: 'r', c: 'B' },
            { t: 'n', c: 'B' },
            { t: 'b', c: 'B' },
            { t: 'q', c: 'B' },
            { t: 'k', c: 'B' },
            { t: 'b', c: 'B' },
            { t: 'n', c: 'B' },
            { t: 'r', c: 'B' }
          ],
          Array(8).fill({ t: 'p', c: 'B' }),
          emptyRow(),
          emptyRow(),
          emptyRow(),
          emptyRow(),
          Array(8).fill({ t: 'p', c: 'W' }),
          [
            { t: 'r', c: 'W' },
            { t: 'n', c: 'W' },
            { t: 'b', c: 'W' },
            { t: 'q', c: 'W' },
            { t: 'k', c: 'W' },
            { t: 'b', c: 'W' },
            { t: 'n', c: 'W' },
            { t: 'r', c: 'W' }
          ]
        ].map((row) => row.map((p) => (p ? { ...p } : null)));
        turn = 'W';
        gameOver = false;
      }

      function inBounds(r, c) {
        return r >= 0 && r < 8 && c >= 0 && c < 8;
      }

      function renderBoard() {
        const lines = [];
        for (let r = 0; r < 8; r++) {
          const rowIdx = 8 - r;
          const cells = [rowIdx];
          for (let c = 0; c < 8; c++) {
            const piece = board[r][c];
            const sym = piece
              ? piece.c === 'W'
                ? piece.t.toUpperCase()
                : piece.t
              : '.';
            cells.push(sym);
          }
          lines.push(cells.join(' '));
        }
        lines.push('  a b c d e f g h');
        appendLine('');
        lines.forEach((l) => appendLine(l));
        appendLine('');
      }

      function coordToIdx(coord) {
        if (!coord || coord.length < 2) return null;
        const file = coord[0].toLowerCase();
        const rank = parseInt(coord[1], 10);
        const c = files.indexOf(file);
        const r = 8 - rank;
        if (c === -1 || Number.isNaN(r) || r < 0 || r > 7) return null;
        return { r, c };
      }

      function isEnemy(a, b) {
        return a && b && a.c !== b.c;
      }

      function pushMoveIfValid(moves, r, c, color) {
        if (!inBounds(r, c)) return false;
        const dest = board[r][c];
        if (!dest) {
          moves.push({ r, c });
          return true;
        }
        if (dest.c !== color) {
          moves.push({ r, c });
        }
        return false;
      }

      function rayMoves(r, c, color, deltas) {
        const moves = [];
        deltas.forEach(([dr, dc]) => {
          let nr = r + dr;
          let nc = c + dc;
          while (inBounds(nr, nc)) {
            const cont = pushMoveIfValid(moves, nr, nc, color);
            if (board[nr][nc]) break;
            nr += dr;
            nc += dc;
          }
        });
        return moves;
      }

      function movesForPiece(r, c, piece) {
        if (!piece) return [];
        const { t, c: color } = piece;
        const moves = [];
        if (t === 'p') {
          const dir = color === 'W' ? -1 : 1;
          const startRow = color === 'W' ? 6 : 1;
          const one = { r: r + dir, c };
          if (inBounds(one.r, one.c) && !board[one.r][one.c]) moves.push(one);
          const two = { r: r + dir * 2, c };
          if (r === startRow && !board[one.r][one.c] && inBounds(two.r, two.c) && !board[two.r][two.c]) {
            moves.push(two);
          }
          const caps = [
            { r: r + dir, c: c + 1 },
            { r: r + dir, c: c - 1 }
          ];
          caps.forEach(({ r: rr, c: cc }) => {
            if (inBounds(rr, cc) && board[rr][cc] && isEnemy(board[rr][cc], piece)) {
              moves.push({ r: rr, c: cc });
            }
          });
        } else if (t === 'n') {
          const jumps = [
            [1, 2], [2, 1], [-1, 2], [-2, 1],
            [1, -2], [2, -1], [-1, -2], [-2, -1],
          ];
          jumps.forEach(([dr, dc]) => {
            const nr = r + dr;
            const nc = c + dc;
            if (!inBounds(nr, nc)) return;
            const dest = board[nr][nc];
            if (!dest || dest.c !== color) moves.push({ r: nr, c: nc });
          });
        } else if (t === 'b') {
          return rayMoves(r, c, color, [
            [1, 1], [1, -1], [-1, 1], [-1, -1]
          ]);
        } else if (t === 'r') {
          return rayMoves(r, c, color, [
            [1, 0], [-1, 0], [0, 1], [0, -1]
          ]);
        } else if (t === 'q') {
          return rayMoves(r, c, color, [
            [1, 1], [1, -1], [-1, 1], [-1, -1],
            [1, 0], [-1, 0], [0, 1], [0, -1]
          ]);
        } else if (t === 'k') {
          const steps = [
            [1, 1], [1, 0], [1, -1],
            [0, 1], [0, -1],
            [-1, 1], [-1, 0], [-1, -1]
          ];
          steps.forEach(([dr, dc]) => pushMoveIfValid(moves, r + dr, c + dc, color));
        }
        return moves;
      }

      function allMoves(color) {
        const list = [];
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = board[r][c];
            if (p && p.c === color) {
              movesForPiece(r, c, p).forEach((dest) => {
                list.push({ from: { r, c }, to: dest });
              });
            }
          }
        }
        return list;
      }

      function attemptMove(from, to) {
        const piece = board[from.r][from.c];
        if (!piece) {
          appendLine('NO PIECE AT SOURCE.');
          return false;
        }
        if (piece.c !== turn) {
          appendLine('NOT YOUR PIECE.');
          return false;
        }
        const moves = movesForPiece(from.r, from.c, piece);
        if (!moves.some((m) => m.r === to.r && m.c === to.c)) {
          appendLine('ILLEGAL MOVE FOR THAT PIECE.');
          return false;
        }
        const destPiece = board[to.r][to.c];
        board[to.r][to.c] = piece;
        board[from.r][from.c] = null;
        if (piece.t === 'p' && (to.r === 0 || to.r === 7)) piece.t = 'q';
        renderBoard();
        if (destPiece && destPiece.t === 'k') {
          appendLine(`${turn === 'W' ? 'WHITE' : 'BLACK'} CAPTURES THE KING.`, 'system');
          appendLine('GAME OVER.', 'system');
          gameOver = true;
          appendLine('TYPE RESET TO PLAY AGAIN OR EXIT TO RETURN.', 'system');
          return true;
        }
        turn = turn === 'W' ? 'B' : 'W';
        return true;
      }

      function aiMove() {
        const moves = allMoves('B');
        if (!moves.length) {
          appendLine('AI HAS NO MOVES. STALEMATE.', 'system');
          gameOver = true;
          return;
        }
        const choice = moves[Math.floor(Math.random() * moves.length)];
        attemptMove(choice.from, choice.to);
        if (!gameOver && turn === 'B') {
          // If move failed somehow, avoid infinite loop
          turn = 'W';
        }
      }

      function start() {
        resetBoard();
        appendLine('CHESS', 'system');
        appendLine('ENTER MOVES LIKE "E2 E4".', 'system');
        appendLine('TYPE "MODE HUMAN" FOR PASS-AND-PLAY OR "MODE AI" TO FACE WOPR.', 'system');
        appendLine('TYPE RESET TO RESTART, EXIT TO LEAVE.', 'system');
        renderBoard();
      }

      function handleInput(raw) {
        const text = raw.trim();
        const upper = text.toUpperCase();

        if (upper === 'EXIT' || upper === '/EXIT' || upper === 'QUIT') {
          appendLine('EXITING CHESS. RETURNING TO TERMINAL.', 'system');
          currentGame = null;
          return;
        }

        if (upper === 'RESET') {
          resetBoard();
          renderBoard();
          return;
        }

        if (upper === 'MODE HUMAN') {
          vsAI = false;
          appendLine('MODE SET: HUMAN VS HUMAN.');
          return;
        }

        if (upper === 'MODE AI') {
          vsAI = true;
          appendLine('MODE SET: HUMAN VS WOPR.');
          return;
        }

        if (gameOver) {
          appendLine('GAME OVER. TYPE RESET OR EXIT.');
          return;
        }

        const parts = text.split(/\s+/);
        if (parts.length < 2) {
          appendLine('ENTER A MOVE LIKE "E2 E4".');
          return;
        }
        const from = coordToIdx(parts[0]);
        const to = coordToIdx(parts[1]);
        if (!from || !to) {
          appendLine('INVALID COORDINATES. USE A-H + 1-8.');
          return;
        }
        const moved = attemptMove(from, to);
        if (moved && !gameOver && vsAI && turn === 'B') {
          appendLine('WOPR THINKING...');
          setTimeout(() => {
            if (!gameOver) {
              aiMove();
            }
          }, 300);
        }
      }

      return { start, handleInput };
    }

    // --- CHECKERS -------------------------------------------------------------
    function createCheckersGame() {
      let board = [];
      let turn = 'R'; // Red moves first
      let vsAI = true;
      let gameOver = false;

      function reset() {
        board = Array.from({ length: 8 }, () => Array(8).fill(null));
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 8; c++) {
            if ((r + c) % 2 === 1) board[r][c] = { c: 'B', k: false };
          }
        }
        for (let r = 5; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            if ((r + c) % 2 === 1) board[r][c] = { c: 'R', k: false };
          }
        }
        turn = 'R';
        gameOver = false;
      }

      function drawBoard() {
        appendLine('');
        for (let r = 0; r < 8; r++) {
          const rowIdx = 8 - r;
          let line = rowIdx + ' ';
          for (let c = 0; c < 8; c++) {
            const p = board[r][c];
            let sym = ((r + c) % 2 === 0) ? '.' : '_';
            if (p) sym = p.c === 'R' ? 'r' : 'b';
            if (p && p.k) sym = sym.toUpperCase();
            line += sym + ' ';
          }
          appendLine(line);
        }
        appendLine('  a b c d e f g h');
        appendLine('');
      }

      function coordToIdx(coord) {
        const files = 'abcdefgh';
        const file = coord[0].toLowerCase();
        const rank = parseInt(coord[1], 10);
        const c = files.indexOf(file);
        const r = 8 - rank;
        if (c === -1 || Number.isNaN(r)) return null;
        return { r, c };
      }

      function validMovesFrom(r, c, piece) {
        if (!piece) return [];
        const dirs = [];
        if (piece.c === 'R' || piece.k) dirs.push([-1, -1], [-1, 1]);
        if (piece.c === 'B' || piece.k) dirs.push([1, -1], [1, 1]);
        const moves = [];
        dirs.forEach(([dr, dc]) => {
          const nr = r + dr;
          const nc = c + dc;
          if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
            if (!board[nr][nc]) moves.push({ r: nr, c: nc, capture: false });
            else if (board[nr][nc].c !== piece.c) {
              const jr = nr + dr;
              const jc = nc + dc;
              if (jr >= 0 && jr < 8 && jc >= 0 && jc < 8 && !board[jr][jc]) {
                moves.push({ r: jr, c: jc, capture: true, jumped: { r: nr, c: nc } });
              }
            }
          }
        });
        return moves;
      }

      function allMoves(color) {
        const list = [];
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = board[r][c];
            if (p && p.c === color) {
              validMovesFrom(r, c, p).forEach((m) => list.push({ from: { r, c }, ...m }));
            }
          }
        }
        return list;
      }

      function attemptMove(from, to) {
        const piece = board[from.r][from.c];
        if (!piece) {
          appendLine('NO PIECE AT SOURCE.');
          return false;
        }
        if (piece.c !== turn) {
          appendLine('NOT YOUR TURN.');
          return false;
        }
        const moves = validMovesFrom(from.r, from.c, piece);
        const selected = moves.find((m) => m.r === to.r && m.c === to.c);
        if (!selected) {
          appendLine('ILLEGAL MOVE.');
          return false;
        }
        board[to.r][to.c] = piece;
        board[from.r][from.c] = null;
        if (selected.capture && selected.jumped) {
          board[selected.jumped.r][selected.jumped.c] = null;
        }
        if (piece.c === 'R' && to.r === 0) piece.k = true;
        if (piece.c === 'B' && to.r === 7) piece.k = true;
        drawBoard();
        const enemy = allMoves(turn === 'R' ? 'B' : 'R');
        if (!enemy.length) {
          appendLine(`${turn === 'R' ? 'RED' : 'BLACK'} WINS!`, 'system');
          gameOver = true;
          appendLine('TYPE RESET TO PLAY AGAIN OR EXIT TO RETURN.', 'system');
          return true;
        }
        turn = turn === 'R' ? 'B' : 'R';
        return true;
      }

      function aiMove() {
        const moves = allMoves('B');
        if (!moves.length) return;
        const choice = moves[Math.floor(Math.random() * moves.length)];
        attemptMove(choice.from, { r: choice.r, c: choice.c });
      }

      function start() {
        reset();
        appendLine('CHECKERS', 'system');
        appendLine('ENTER MOVES LIKE "A3 B4" (FROM TO).', 'system');
        appendLine('TYPE MODE HUMAN FOR PASS-AND-PLAY, MODE AI FOR WOPR OPPONENT.', 'system');
        appendLine('TYPE RESET TO RESTART, EXIT TO LEAVE.', 'system');
        drawBoard();
      }

      function handleInput(raw) {
        const text = raw.trim();
        const upper = text.toUpperCase();
        if (upper === 'EXIT' || upper === '/EXIT' || upper === 'QUIT') {
          appendLine('EXITING CHECKERS. RETURNING TO TERMINAL.', 'system');
          currentGame = null;
          return;
        }
        if (upper === 'RESET') {
          reset();
          drawBoard();
          return;
        }
        if (upper === 'MODE HUMAN') {
          vsAI = false;
          appendLine('MODE SET: HUMAN VS HUMAN.');
          return;
        }
        if (upper === 'MODE AI') {
          vsAI = true;
          appendLine('MODE SET: HUMAN VS WOPR.');
          return;
        }
        if (gameOver) {
          appendLine('GAME OVER. TYPE RESET OR EXIT.');
          return;
        }
        const parts = text.split(/\s+/);
        if (parts.length < 2) {
          appendLine('ENTER MOVE AS "A3 B4".');
          return;
        }
        const from = coordToIdx(parts[0]);
        const to = coordToIdx(parts[1]);
        if (!from || !to) {
          appendLine('INVALID COORDINATES.');
          return;
        }
        const moved = attemptMove(from, to);
        if (moved && !gameOver && vsAI && turn === 'B') {
          appendLine('WOPR PROCESSING...');
          setTimeout(() => {
            if (!gameOver) aiMove();
          }, 300);
        }
      }

      return { start, handleInput };
    }

    // --- BLACKJACK ------------------------------------------------------------
    function createBlackjackGame() {
      const suits = ['♠', '♥', '♦', '♣'];
      const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
      let deck = [];
      let player = [];
      let dealer = [];
      let roundOver = false;

      function buildDeck() {
        deck = [];
        suits.forEach((s) => {
          ranks.forEach((r) => deck.push({ r, s }));
        });
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
      }

      function drawCard() {
        if (!deck.length) buildDeck();
        return deck.pop();
      }

      function handValue(hand) {
        let total = 0;
        let aces = 0;
        hand.forEach((c) => {
          if (c.r === 'A') {
            aces++;
            total += 11;
          } else if (['K', 'Q', 'J'].includes(c.r)) {
            total += 10;
          } else {
            total += parseInt(c.r, 10);
          }
        });
        while (total > 21 && aces > 0) {
          total -= 10;
          aces--;
        }
        return total;
      }

      function renderHands(showDealer = false) {
        const playerLine = 'PLAYER: ' + player.map((c) => `${c.r}${c.s}`).join(' ');
        const dealerLine = 'DEALER: ' + dealer.map((c, i) => (showDealer || i === 0 ? `${c.r}${c.s}` : '??')).join(' ');
        appendLine(playerLine);
        appendLine(`PLAYER TOTAL: ${handValue(player)}`);
        appendLine(dealerLine);
        if (showDealer) appendLine(`DEALER TOTAL: ${handValue(dealer)}`);
        appendLine('');
      }

      function checkOutcome(showDealer = true) {
        const pv = handValue(player);
        const dv = handValue(dealer);
        if (pv > 21) {
          appendLine('PLAYER BUSTS. DEALER WINS.', 'system');
          return true;
        }
        if (dv > 21) {
          appendLine('DEALER BUSTS. PLAYER WINS.', 'system');
          return true;
        }
        if (showDealer) {
          if (pv > dv) appendLine('PLAYER WINS.', 'system');
          else if (pv < dv) appendLine('DEALER WINS.', 'system');
          else appendLine('PUSH.');
          return true;
        }
        return false;
      }

      function startRound() {
        roundOver = false;
        player = [drawCard(), drawCard()];
        dealer = [drawCard(), drawCard()];
        appendLine('BLACKJACK - NEW ROUND', 'system');
        appendLine('TYPE HIT, STAND, OR EXIT TO LEAVE.');
        renderHands(false);
        if (handValue(player) === 21) {
          appendLine('BLACKJACK!');
          endRound();
        }
      }

      function endRound() {
        roundOver = true;
        while (handValue(dealer) < 17) {
          dealer.push(drawCard());
        }
        renderHands(true);
        checkOutcome(true);
        appendLine('TYPE DEAL TO PLAY AGAIN OR EXIT TO RETURN.', 'system');
      }

      function start() {
        buildDeck();
        startRound();
      }

      function handleInput(raw) {
        const text = raw.trim().toUpperCase();
        if (text === 'EXIT' || text === '/EXIT' || text === 'QUIT') {
          appendLine('EXITING BLACKJACK. RETURNING TO TERMINAL.', 'system');
          currentGame = null;
          return;
        }
        if (text === 'DEAL') {
          startRound();
          return;
        }
        if (roundOver) {
          appendLine('ROUND COMPLETE. TYPE DEAL OR EXIT.');
          return;
        }
        if (text === 'HIT') {
          player.push(drawCard());
          renderHands(false);
          if (handValue(player) >= 21) {
            endRound();
          }
          return;
        }
        if (text === 'STAND') {
          endRound();
          return;
        }
        appendLine('UNKNOWN COMMAND. USE HIT, STAND, DEAL, OR EXIT.');
      }

      return { start, handleInput };
    }

    // --- SOLITAIRE (MINI KLONDIKE) -------------------------------------------
    function createSolitaireGame() {
      const suits = ['♠', '♥', '♦', '♣'];
      const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
      let stock = [];
      let waste = [];
      let tableaus = [];
      let foundations = { '♠': [], '♥': [], '♦': [], '♣': [] };

      function buildDeck() {
        const deck = [];
        suits.forEach((s) => ranks.forEach((r) => deck.push({ r, s, up: false })));
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
      }

      function reset() {
        stock = buildDeck();
        waste = [];
        foundations = { '♠': [], '♥': [], '♦': [], '♣': [] };
        tableaus = Array.from({ length: 7 }, (_, idx) => []);
        for (let i = 0; i < 7; i++) {
          for (let j = 0; j <= i; j++) {
            const card = stock.pop();
            card.up = j === i; // top card face up
            tableaus[i].push(card);
          }
        }
        appendLine('SOLITAIRE: BUILD FOUNDATIONS BY SUIT FROM A TO K.', 'system');
        appendLine('COMMANDS: DRAW, MOVE WASTE T# | FSUIT, MOVE T# T# N, MOVE T# FSUIT, FLIP T#.', 'system');
        appendLine('EXIT TO LEAVE, RESET TO REDEAL.', 'system');
        render();
      }

      function cardColor(card) {
        return card.s === '♥' || card.s === '♦' ? 'red' : 'black';
      }

      function rankIndex(r) {
        return ranks.indexOf(r);
      }

      function render() {
        appendLine('');
        const wasteTop = waste.length ? `${waste[waste.length - 1].r}${waste[waste.length - 1].s}` : 'EMPTY';
        appendLine(`STOCK: ${stock.length} | WASTE: ${wasteTop}`);
        appendLine('FOUNDATIONS: ' + suits.map((s) => `${s}:${foundations[s].length ? foundations[s][foundations[s].length - 1].r : '-'}`).join(' '));
        appendLine('TABLEAU:');
        tableaus.forEach((pile, idx) => {
          const display = pile.map((c) => (c.up ? `${c.r}${c.s}` : '##')).join(' ');
          appendLine(`  T${idx + 1}: ${display}`);
        });
        appendLine('');
      }

      function draw() {
        if (!stock.length) {
          stock = waste.reverse().map((c) => ({ ...c, up: false }));
          waste = [];
          appendLine('RESHUFFLING WASTE INTO STOCK.', 'system');
        }
        if (stock.length) {
          const card = stock.pop();
          card.up = true;
          waste.push(card);
        }
        render();
      }

      function canPlaceOnTableau(card, destCard) {
        if (!destCard) return card.r === 'K';
        return cardColor(card) !== cardColor(destCard) && rankIndex(card.r) === rankIndex(destCard.r) - 1;
      }

      function canPlaceOnFoundation(card, suitPile) {
        if (card.s !== suitPile.suit) return false;
        const expected = suitPile.cards.length === 0 ? 0 : rankIndex(suitPile.cards[suitPile.cards.length - 1].r) + 1;
        return rankIndex(card.r) === expected;
      }

      function moveWaste(target) {
        if (!waste.length) {
          appendLine('NO CARD IN WASTE.');
          return;
        }
        const card = waste[waste.length - 1];
        if (target.startsWith('T')) {
          const idx = parseInt(target.slice(1), 10) - 1;
          const dest = tableaus[idx];
          if (!dest) return appendLine('UNKNOWN TABLEAU.');
          const top = dest.length ? dest[dest.length - 1] : null;
          if (canPlaceOnTableau(card, top)) {
            waste.pop();
            dest.push(card);
          } else {
            appendLine('CANNOT PLACE WASTE THERE.');
          }
        } else if (target.startsWith('F')) {
          const suit = target.slice(1);
          if (!foundations[suit]) return appendLine('UNKNOWN FOUNDATION. USE F♠/F♥/F♦/F♣.');
          const pile = { suit, cards: foundations[suit] };
          if (canPlaceOnFoundation(card, pile)) {
            waste.pop();
            foundations[suit].push(card);
          } else {
            appendLine('CANNOT PLACE ON FOUNDATION.');
          }
        }
        render();
      }

      function moveTableau(sourceIdx, dest, count) {
        const src = tableaus[sourceIdx];
        if (!src || !src.length) return appendLine('SOURCE EMPTY.');
        if (count > src.length) return appendLine('NOT ENOUGH CARDS.');
        const moving = src.slice(src.length - count);
        if (!moving[0].up) return appendLine('TURN CARDS FACE UP FIRST (FLIP).');
        if (dest.startsWith('T')) {
          const destIdx = parseInt(dest.slice(1), 10) - 1;
          const dst = tableaus[destIdx];
          if (!dst) return appendLine('UNKNOWN TABLEAU.');
          const destTop = dst.length ? dst[dst.length - 1] : null;
          if (!canPlaceOnTableau(moving[0], destTop)) return appendLine('ILLEGAL TABLEAU MOVE.');
          tableaus[sourceIdx] = src.slice(0, src.length - count);
          dst.push(...moving);
        } else if (dest.startsWith('F') && count === 1) {
          const suit = dest.slice(1);
          if (!foundations[suit]) return appendLine('UNKNOWN FOUNDATION.');
          const pile = { suit, cards: foundations[suit] };
          if (!canPlaceOnFoundation(moving[0], pile)) return appendLine('ILLEGAL FOUNDATION MOVE.');
          tableaus[sourceIdx].pop();
          foundations[suit].push(moving[0]);
        } else {
          return appendLine('INVALID DESTINATION.');
        }
        if (tableaus[sourceIdx].length && !tableaus[sourceIdx][tableaus[sourceIdx].length - 1].up) {
          tableaus[sourceIdx][tableaus[sourceIdx].length - 1].up = true;
        }
        render();
      }

      function flipTableau(idx) {
        const pile = tableaus[idx];
        if (!pile || !pile.length) return appendLine('NOTHING TO FLIP.');
        const top = pile[pile.length - 1];
        if (top.up) return appendLine('TOP CARD ALREADY FACE UP.');
        top.up = true;
        render();
      }

      function checkWin() {
        const total = Object.values(foundations).reduce((s, p) => s + p.length, 0);
        if (total === 52) {
          appendLine('SOLITAIRE COMPLETE. WELL DONE!', 'system');
        }
      }

      function start() {
        reset();
      }

      function handleInput(raw) {
        const text = raw.trim();
        const upper = text.toUpperCase();
        if (upper === 'EXIT' || upper === '/EXIT' || upper === 'QUIT') {
          appendLine('EXITING SOLITAIRE. RETURNING TO TERMINAL.', 'system');
          currentGame = null;
          return;
        }
        if (upper === 'RESET') {
          reset();
          return;
        }
        if (upper === 'DRAW') {
          draw();
          checkWin();
          return;
        }
        const parts = text.split(/\s+/);
        if (parts[0].toUpperCase() === 'MOVE') {
          if (parts.length < 3) return appendLine('USAGE: MOVE SOURCE DEST [COUNT].');
          const source = parts[1].toUpperCase();
          const dest = parts[2].toUpperCase();
          const count = parts[3] ? parseInt(parts[3], 10) : 1;
          if (source === 'WASTE') {
            moveWaste(dest);
            checkWin();
            return;
          }
          if (source.startsWith('T')) {
            const idx = parseInt(source.slice(1), 10) - 1;
            moveTableau(idx, dest, count || 1);
            checkWin();
            return;
          }
        }
        if (parts[0].toUpperCase() === 'FLIP' && parts[1]) {
          const idx = parseInt(parts[1].slice(1), 10) - 1;
          flipTableau(idx);
          return;
        }
        appendLine('UNKNOWN COMMAND. TRY DRAW, MOVE, FLIP, RESET, OR EXIT.');
      }

      return { start, handleInput };
    }

    // --- GLOBAL THERMONUCLEAR WAR EXPERIENCE ----------------------------------
    function createThermonuclearWarExperience() {
      const script = [
        'LINKING TO STRATEGIC LAUNCH SILOS...',
        'AUTHORIZING WOPR TO SELECT TARGETS...',
        'SIMULATION ONLINE. READY TO PLAY?',
      ];
      let step = 0;
      let concluded = false;

      function start() {
        appendLine('GLOBAL THERMONUCLEAR WAR (CINEMATIC MODE)', 'system');
        appendLine('TYPE YES TO PROCEED OR EXIT TO ABORT.', 'system');
      }

      function handleInput(raw) {
        const text = raw.trim().toUpperCase();
        if (text === 'EXIT' || text === '/EXIT' || text === 'QUIT') {
          appendLine('SIMULATION TERMINATED. RETURNING TO TERMINAL.', 'system');
          currentGame = null;
          return;
        }
        if (concluded) {
          appendLine('THE ONLY WINNING MOVE IS NOT TO PLAY.', 'system');
          return;
        }
        if (step === 0 && text === 'YES') {
          appendLine(script[step]);
          step++;
          appendLine('CHOOSE YOUR SIDE: USA OR USSR?');
          return;
        }
        if (step === 1 && (text === 'USA' || text === 'USSR')) {
          appendLine(`SIDE CONFIRMED: ${text}. TARGET DATABASE LOADED.`);
          step++;
          appendLine('ENTER A TARGET CITY OR TYPE RANDOM FOR AUTOMATIC SELECTION.');
          return;
        }
        if (step === 2) {
          appendLine('COORDINATES LOCKED. PREPPING MISSILE TRAJECTORIES...');
          step++;
          setTimeout(() => {
            appendLine('LAUNCH SEQUENCE INITIATED. 3... 2... 1...');
            setTimeout(() => {
              appendLine('MISSILES AWAY. COUNTERFORCE RESPONSE DETECTED.');
              setTimeout(() => {
                appendLine('WOPR RUNNING OUTCOME ANALYSIS...');
                setTimeout(() => {
                  appendLine('AFTERMATH: GLOBAL DEVASTATION. NO WINNERS.');
                  appendLine('THE ONLY WINNING MOVE IS NOT TO PLAY', 'system');
                  appendLine('SIMULATION COMPLETE. EXITING.', 'system');
                  concluded = true;
                  currentGame = null;
                }, 800);
              }, 800);
            }, 800);
          }, 600);
          return;
        }
        appendLine('TYPE YES TO BEGIN OR EXIT TO LEAVE.');
      }

      return { start, handleInput };
    }

    // --- CLI COMMANDS ---------------------------------------------------------
    function handleCommand(text) {
      const parts = text.trim().split(/\s+/);
      const cmd = parts[0].toLowerCase();
      const args = parts.slice(1);

      switch (cmd) {
        case '/help':
          appendLine('AVAILABLE COMMANDS:', 'system');
          appendLine('  /help         - SHOW THIS HELP', 'system');
          appendLine('  /chat         - ENTER GLOBAL CHAT', 'system');
          appendLine('  /games        - LIST AVAILABLE WOPR SCENARIOS', 'system');
          appendLine('  /settings     - TERMINAL SETTINGS (PLACEHOLDER)', 'system');
          appendLine('  /defcon N     - SET SIMULATED DEFCON LEVEL (1-5)', 'system');
          appendLine('  LAUNCH <NAME> - START A GAME (E.G. LAUNCH TIC-TAC-TOE)', 'system');
          return true;

        case '/chat':
          appendLine('ENTERING GLOBAL CHAT CHANNEL...', 'system');
          appendLine('MESSAGES WITHOUT "/" PREFIX WILL BE BROADCAST.', 'system');
          return true;

        case '/games':
          appendLine('AVAILABLE WOPR SCENARIOS:', 'system');
          appendLine('  TIC-TAC-TOE', 'system');
          appendLine('  CHESS', 'system');
          appendLine('  CHECKERS', 'system');
          appendLine('  BLACKJACK', 'system');
          appendLine('  SOLITAIRE', 'system');
          appendLine('  GLOBAL THERMONUCLEAR WAR (SIMULATION)', 'system');
          appendLine('', 'system');
          appendLine('TYPE:  "LAUNCH <NAME>"  TO START A SCENARIO.', 'system');
          appendLine('EXAMPLE: LAUNCH TIC-TAC-TOE', 'system');
          return true;

        case '/settings':
          appendLine('TERMINAL SETTINGS (PLACEHOLDER):', 'system');
          appendLine('  - FUTURE: COLOR THEMES, SOUND FX, TEXT SPEED', 'system');
          return true;

        case '/defcon':
          if (args.length === 0) {
            appendLine('USAGE: /defcon N   (1 = NUCLEAR WAR, 5 = PEACE)', 'warn');
            return true;
          }
          const level = parseInt(args[0], 10);
          if (isNaN(level) || level < 1 || level > 5) {
            appendLine('INVALID DEFCON LEVEL. USE 1-5.', 'warn');
            return true;
          }
          setDefcon(level);
          appendLine(`SIMULATION ALERT: DEFCON SET TO ${level}.`, 'system');
          return true;

        case 'launch': // user typed "LAUNCH ..." without slash
        case '/launch':
          const name = args.join(' ').toLowerCase();
          if (!name) {
            appendLine('USAGE: LAUNCH <NAME>. EXAMPLE: LAUNCH TIC-TAC-TOE', 'warn');
            return true;
          }

          if (name === 'tic-tac-toe' || name === 'tic' || name === 'ttt') {
            currentGame = createTicTacToeGame();
            appendLine('INITIATING SCENARIO: TIC-TAC-TOE', 'system');
            currentGame.start();
            return true;
          }

          if (name === 'chess') {
            currentGame = createChessGame();
            appendLine('INITIATING SCENARIO: CHESS', 'system');
            currentGame.start();
            return true;
          }

          if (name === 'checkers') {
            currentGame = createCheckersGame();
            appendLine('INITIATING SCENARIO: CHECKERS', 'system');
            currentGame.start();
            return true;
          }

          if (name === 'blackjack' || name === 'black jack') {
            currentGame = createBlackjackGame();
            appendLine('INITIATING SCENARIO: BLACKJACK', 'system');
            currentGame.start();
            return true;
          }

          if (name === 'solitaire' || name === 'solitare' || name === 'klondike') {
            currentGame = createSolitaireGame();
            appendLine('INITIATING SCENARIO: SOLITAIRE', 'system');
            currentGame.start();
            return true;
          }

          if (name === 'global thermonuclear war' || name === 'gtw') {
            currentGame = createThermonuclearWarExperience();
            appendLine('INITIATING SCENARIO: GLOBAL THERMONUCLEAR WAR', 'system');
            currentGame.start();
            return true;
          }

          appendLine(`SCENARIO "${name.toUpperCase()}" NOT IMPLEMENTED YET.`, 'warn');
          return true;

        default:
          appendLine(`UNKNOWN COMMAND: ${cmd}. TYPE /HELP FOR OPTIONS.`, 'warn');
          return true;
      }
    }

    // --- SOCKET HANDLERS ------------------------------------------------------
    socket.on('chat-message', (msg) => {
      const time = new Date(msg.timestamp).toLocaleTimeString();
      const line = `[${time}] ${msg.codename}: ${msg.text}`;
      appendLine(line);
    });

    socket.on('system-message', (text) => {
      appendLine(`*** ${text} ***`, 'system');
    });

    socket.on('user-list', (users) => {
      const count = users.length || 0;
      statusLine.textContent =
        'ACTIVE LINKS: ' + String(count).padStart(2, '0');
      updateMarkers(users);
    });

    // Init map & boot sequence
    window.addEventListener('load', () => {
      initMap();
      setDefcon(5);
      runBootSequence();
    });

    // --- INPUT HANDLING -------------------------------------------------------
    chatForm.addEventListener('submit', (e) => {
      e.preventDefault();
      const text = chatInput.value.trim();
      if (!text) return;

      // If a game is active, send *all* input to it
      if (currentGame) {
        currentGame.handleInput(text);
        chatInput.value = '';
        return;
      }

      // No game: treat "/" as command, else global chat
      if (text.startsWith('/')) {
        handleCommand(text);
      } else {
        socket.emit('chat-message', text);
      }

      chatInput.value = '';
    });
  </script>
</body>
</html>

