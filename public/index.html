<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GLOBAL THERMONUCLEAR CHAT</title>

  <!-- Leaflet map CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    :root {
      background-color: #000;
      color: #33ff66;
      font-family: "Courier New", monospace;

      --bg-color: #000;
      --primary: #33ff66;
      --secondary: #55ff88;
      --warn: #ff9933;
      --muted: #145f2a;
      --map-hue: 80deg;
    }

    body.defcon-theme-5 {
      --primary: #33ff66;
      --secondary: #55ff88;
      --warn: #ff9933;
      --muted: #145f2a;
      --map-hue: 80deg;
    }

    body.defcon-theme-4 {
      --primary: #7fff33;
      --secondary: #a2ff66;
      --warn: #ffb733;
      --muted: #3c661c;
      --map-hue: 60deg;
    }

    body.defcon-theme-3 {
      --primary: #ffff33;
      --secondary: #ffff7a;
      --warn: #ffb733;
      --muted: #666214;
      --map-hue: 40deg;
    }

    body.defcon-theme-2 {
      --primary: #ff9933;
      --secondary: #ffc266;
      --warn: #ff7a33;
      --muted: #663d14;
      --map-hue: 10deg;
    }

    body.defcon-theme-1 {
      --primary: #ff3333;
      --secondary: #ff6666;
      --warn: #ffcc66;
      --muted: #661414;
      --map-hue: -20deg;
    }

    * {
      box-sizing: border-box;
    }

    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: var(--bg-color);
      color: var(--primary);
      transition: color 0.3s ease, background-color 0.3s ease;
    }

    .crt-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(
        to bottom,
        rgba(0, 0, 0, 0.3) 0px,
        rgba(0, 0, 0, 0.3) 1px,
        rgba(0, 0, 0, 0.0) 3px,
        rgba(0, 0, 0, 0.0) 4px
      );
      mix-blend-mode: multiply;
      z-index: 10;
    }

    .frame {
      width: 90vw;
      height: 90vh;
      border: 1px solid var(--primary);
      padding: 8px;
      display: flex;
      flex-direction: column;
      background-color: var(--bg-color);
      position: relative;
      overflow: hidden;
      transition: border-color 0.3s ease, background-color 0.3s ease;
    }

    .header {
      border-bottom: 1px solid var(--primary);
      padding-bottom: 4px;
      margin-bottom: 4px;
      text-transform: uppercase;
      font-size: 12px;
      letter-spacing: 2px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
    }

    .header-title {
      margin: 0;
    }

    .header-right {
      font-size: 11px;
      text-align: right;
    }

    .defcon {
      font-weight: bold;
    }

    .defcon-level-5 { color: #33ff66; }
    .defcon-level-4 { color: #7fff33; }
    .defcon-level-3 { color: #ffff33; }
    .defcon-level-2 { color: #ff9933; }
    .defcon-level-1 { color: #ff3333; }

    .layout {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 1fr);
      gap: 6px;
      height: 100%;
      min-height: 0;
    }

    .panel {
      border: 1px solid var(--primary);
      display: flex;
      flex-direction: column;
      font-size: 12px;
      transition: border-color 0.3s ease;
      min-width: 0;
      min-height: 0;
    }

    .panel-title {
      border-bottom: 1px solid var(--primary);
      padding: 4px 6px;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: border-color 0.3s ease;
    }

    .panel-body {
      flex: 1;
      padding: 4px 6px;
      overflow-y: auto;
      overflow-x: hidden;
      white-space: pre-wrap;
      min-height: 0;
    }

    .chat-line {
      margin-bottom: 2px;
      overflow-wrap: anywhere;
    }

    .chat-line.system {
      color: var(--secondary);
    }

    .chat-line.warn {
      color: var(--warn);
    }

    .chat-meta {
      color: var(--secondary);
    }

    .chat-text {
      color: var(--primary);
    }

    .panel-body,
    #chat-log {
      scrollbar-width: thin;
      scrollbar-color: var(--primary) rgba(255, 255, 255, 0.05);
    }

    .panel-body::-webkit-scrollbar,
    #chat-log::-webkit-scrollbar {
      width: 8px;
    }

    .panel-body::-webkit-scrollbar-track,
    #chat-log::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
    }

    .panel-body::-webkit-scrollbar-thumb,
    #chat-log::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 4px;
    }

    .card-span {
      font-weight: bold;
      margin-right: 2px;
    }

    .card-span.red {
      color: #ff6b6b;
    }

    .card-span.black {
      color: #f0f0f0;
    }

    .card-span.hidden {
      color: var(--muted);
    }

    .board-grid {
      display: inline-flex;
      flex-direction: column;
      gap: 2px;
      padding: 4px;
      border: 1px solid var(--primary);
      background: rgba(0, 0, 0, 0.4);
    }

    .board-row {
      display: flex;
      gap: 2px;
      align-items: center;
    }

    .board-cell {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 12px;
      text-transform: uppercase;
    }

    .board-cell.light {
      background: rgba(255, 255, 255, 0.05);
    }

    .board-cell.dark {
      background: rgba(0, 0, 0, 0.4);
    }

    .board-label {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--secondary);
      font-size: 11px;
    }

    .piece-white {
      color: #ffffff;
    }

    .piece-green {
      color: #55ff88;
    }

    .checker-red {
      color: #ff6b6b;
    }

    .checker-black {
      color: #f0f0f0;
    }

    #chat-log {
      display: flex;
      flex-direction: column;
      gap: 2px;
      overscroll-behavior: contain;
      scrollbar-gutter: stable;
    }

    .chat-input-row {
      border-top: 1px solid var(--primary);
      padding: 4px 6px;
      display: flex;
      align-items: center;
      gap: 4px;
      transition: border-color 0.3s ease;
    }

    .prompt {
      font-weight: bold;
    }

    #chat-input {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      color: var(--primary);
      font: inherit;
      transition: color 0.3s ease;
    }

    #chat-input::placeholder {
      color: var(--muted);
    }

    .cursor {
      display: inline-block;
      width: 8px;
      animation: blink 1s steps(1) infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    .footer-line {
      margin-top: 4px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 2px;
      opacity: 0.8;
    }

    /* Map look + CRT vibe */
    .map-container {
      width: 100%;
      height: 100%;
      border: 1px solid var(--primary);
      /* Softer green tint */
      filter:
        grayscale(1)
        sepia(1)
        hue-rotate(var(--map-hue))
        saturate(3)
        brightness(0.9)
        contrast(1.3);
      background: #000;
      position: relative;
      overflow: hidden;
      transition: border-color 0.3s ease, filter 0.3s ease;
    }

    .leaflet-container {
      background: #000 !important;
      font-family: "Courier New", monospace;
    }

    .leaflet-control-attribution,
    .leaflet-control-zoom {
      display: none !important;
    }

    /* Green glowing X marker */
    @keyframes pulse {
      0% { text-shadow: 0 0 4px var(--primary); }
      50% { text-shadow: 0 0 8px var(--primary); }
      100% { text-shadow: 0 0 4px var(--primary); }
    }

    .wargames-marker {
      color: var(--primary);
      font-size: 18px;
      line-height: 18px;
      transform: translate(-50%, -50%);
      animation: pulse 2s infinite;
    }

    /* Radar sweep overlay */
    #radar-sweep {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 160%;
      height: 160%;
      border-top: 1px solid var(--primary);
      border-radius: 50%;
      transform-origin: 0 0;
      pointer-events: none;
      mix-blend-mode: screen;
      animation: sweep 4s linear infinite;
      opacity: 0.45;
    }

    @keyframes sweep {
      0% {
        transform: rotate(0deg) translate(-50%, -50%);
      }
      100% {
        transform: rotate(360deg) translate(-50%, -50%);
      }
    }
  </style>
</head>
<body>
  <div class="crt-overlay"></div>

  <div class="frame">
    <div class="header">
      <div>
        <h1 class="header-title">NORAD MAINFRAME / GLOBAL THERMONUCLEAR CHAT</h1>
        <div>SYSTEM STATUS: ONLINE</div>
      </div>
      <div class="header-right">
        <div>SIMULATION CORE: WOPR/SCENARIO-ENGINE</div>
        <div id="defcon-display" class="defcon defcon-level-5">DEFCON: 5</div>
      </div>
    </div>

    <div class="layout">
      <!-- Chat / CLI panel -->
      <div class="panel">
        <div class="panel-title">TERMINAL LINK</div>
        <div id="chat-log" class="panel-body">
          INITIALIZING LINK...
        </div>
        <form id="chat-form" class="chat-input-row">
          <span class="prompt">&gt;</span>
          <input
            id="chat-input"
            type="text"
            autocomplete="off"
            placeholder="TYPE /HELP TO BEGIN..."
          />
          <span class="cursor">█</span>
        </form>
      </div>

      <!-- Right panel: map + status -->
      <div class="panel">
        <div class="panel-title">GLOBAL DISPLAY</div>
        <div class="panel-body" style="display: flex; flex-direction: column;">
          <div id="map" class="map-container">
            <!-- radar sweep overlay will be injected here -->
          </div>

          <div class="footer-line" id="status-line">
            ACTIVE LINKS: 00
          </div>
        </div>
      </div>
    </div>
  </div>

    <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Socket.io client script served from the Node server -->
  <script src="/socket.io/socket.io.js"></script>
  <script type="module">
    const socket = io();
    const chatLog = document.getElementById('chat-log');
    const chatForm = document.getElementById('chat-form');
    const chatInput = document.getElementById('chat-input');
    const statusLine = document.getElementById('status-line');
    const defconDisplay = document.getElementById('defcon-display');

    let currentDefconTheme = 5;

    let map;
    let markersLayer;
    let xIcon;
    let missileLayer;
    let targetLayer;
    const missileTimers = new Set();

    // --- GAME STATE -----------------------------------------------------------
    let currentGame = null; // { start(), handleInput(text) }

    // --- UTIL: append lines ---------------------------------------------------
    function appendLine(content, kind = "normal") {
      const line = document.createElement('div');
      line.classList.add('chat-line');
      if (kind === 'system') line.classList.add('system');
      if (kind === 'warn') line.classList.add('warn');

      function appendChunks(chunks) {
        chunks.forEach((chunk) => {
          if (typeof chunk === 'string') {
            line.appendChild(document.createTextNode(chunk));
          } else if (chunk && chunk.nodeType) {
            line.appendChild(chunk);
          } else if (chunk && typeof chunk === 'object') {
            const span = document.createElement('span');
            span.textContent = chunk.text || '';
            if (chunk.className) {
              chunk.className.split(/\s+/).forEach((cls) => {
                if (cls) span.classList.add(cls);
              });
            }
            line.appendChild(span);
          }
        });
      }

      if (Array.isArray(content)) {
        appendChunks(content);
      } else if (content instanceof Node) {
        line.appendChild(content);
      } else if (content && typeof content === 'object' && 'text' in content) {
        appendChunks([content]);
      } else {
        line.textContent = content;
      }
      chatLog.appendChild(line);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function cardSuitClass(suit) {
      return suit === '♥' || suit === '♦' ? 'red' : 'black';
    }

    function formatCardChunks(cards, { hideFromIndex = null } = {}) {
      const chunks = [];
      cards.forEach((card, idx) => {
        if (idx > 0) chunks.push(' ');
        const shouldHide = hideFromIndex !== null && idx >= hideFromIndex;
        if (!card || !shouldHide) {
          chunks.push({ text: `${card.r}${card.s}`, className: `card-span ${cardSuitClass(card.s)}` });
        } else {
          chunks.push({ text: '??', className: 'card-span hidden' });
        }
      });
      if (!cards.length) chunks.push('EMPTY');
      return chunks;
    }

    function appendCardLine(label, cards, options = {}) {
      const chunks = [{ text: label, className: 'chat-meta' }, ' '];
      chunks.push(...formatCardChunks(cards, options));
      appendLine(chunks);
    }

    function createBoardElement(size, getCellContent, showCoords = true) {
      const wrapper = document.createElement('div');
      wrapper.classList.add('board-grid');

      for (let r = 0; r < size; r++) {
        const rowEl = document.createElement('div');
        rowEl.classList.add('board-row');
        if (showCoords) {
          const label = document.createElement('div');
          label.classList.add('board-label');
          label.textContent = size - r;
          rowEl.appendChild(label);
        }
        for (let c = 0; c < size; c++) {
          const cell = document.createElement('div');
          cell.classList.add('board-cell', (r + c) % 2 === 0 ? 'light' : 'dark');
          const content = getCellContent(r, c);
          if (content) {
            if (typeof content === 'string') {
              cell.textContent = content;
            } else if (content.nodeType) {
              cell.appendChild(content);
            } else if (content.text) {
              const span = document.createElement('span');
              span.textContent = content.text;
              if (content.className) {
                content.className.split(/\s+/).forEach((cls) => cls && span.classList.add(cls));
              }
              cell.appendChild(span);
            }
          }
          rowEl.appendChild(cell);
        }
        wrapper.appendChild(rowEl);
      }

      if (showCoords) {
        const footer = document.createElement('div');
        footer.classList.add('board-row');
        const spacer = document.createElement('div');
        spacer.classList.add('board-label');
        spacer.textContent = '';
        footer.appendChild(spacer);
        for (let c = 0; c < size; c++) {
          const label = document.createElement('div');
          label.classList.add('board-label');
          label.textContent = String.fromCharCode(97 + c);
          footer.appendChild(label);
        }
        wrapper.appendChild(footer);
      }

      return wrapper;
    }

    // --- DEFCON ---------------------------------------------------------------
    function setDefcon(level) {
      level = Math.min(5, Math.max(1, level));
      defconDisplay.textContent = 'DEFCON: ' + level;
      defconDisplay.className = 'defcon defcon-level-' + level;

      if (currentDefconTheme !== level) {
        document.body.classList.remove('defcon-theme-' + currentDefconTheme);
      }
      document.body.classList.add('defcon-theme-' + level);
      currentDefconTheme = level;
    }

    // --- MAP SETUP ------------------------------------------------------------
    function initMap() {
      if (map) return;

      map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        worldCopyJump: true
      }).setView([20, 0], 2);

      // Dark tiles, we tint them green via CSS filter
      L.tileLayer(
        'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png',
        {
          maxZoom: 6,
          minZoom: 1
        }
      ).addTo(map);

      markersLayer = L.layerGroup().addTo(map);
      missileLayer = L.layerGroup().addTo(map);
      targetLayer = L.layerGroup().addTo(map);

      // Neon green "X" icon
      xIcon = L.divIcon({
        className: 'wargames-marker',
        html: '✕',
        iconSize: [18, 18],
        iconAnchor: [9, 9]
      });

      // Radar sweep overlay
      const mapEl = document.getElementById('map');
      const sweep = document.createElement('div');
      sweep.id = 'radar-sweep';
      mapEl.appendChild(sweep);
    }

    function updateMarkers(users) {
      if (!map) initMap();
      markersLayer.clearLayers();

      const coords = [];

      users.forEach((u) => {
        if (typeof u.lat !== 'number' || typeof u.lon !== 'number') return;

        const lat = u.lat;
        const lon = u.lon;
        coords.push([lat, lon]);

        const label = `${u.codename || 'LINK'}\n${u.city || ''}${u.city && u.country ? ', ' : ''}${u.country || ''}`;

        const marker = L.marker([lat, lon], {
          icon: xIcon
        });

        marker.bindPopup(label.replace('\n', '<br/>'));
        markersLayer.addLayer(marker);
      });

      if (coords.length) {
        const bounds = L.latLngBounds(coords);
        map.fitBounds(bounds.pad(0.5));
      }
    }

    function setMapView(center = [20, 0], zoom = 2) {
      if (!map) initMap();
      map.setView(center, zoom);
    }

    function clearMissileAnimations() {
      missileTimers.forEach((timer) => clearInterval(timer));
      missileTimers.clear();
      if (missileLayer) missileLayer.clearLayers();
    }

    function animateMissilePath(from, to, options = {}) {
      if (!map) initMap();
      if (!missileLayer) missileLayer = L.layerGroup().addTo(map);
      const color = options.color || '#ff3333';
      const duration = options.duration || 3000;
      const steps = options.steps || 40;
      const curveHeight = options.curveHeight || 0;
      const dx = to[1] - from[1];
      const dy = to[0] - from[0];
      const distance = Math.hypot(dx, dy) || 1;
      const perpX = -dy / distance;
      const perpY = dx / distance;

      const pathPoints = [];
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const offset = Math.sin(Math.PI * t) * curveHeight;
        const lat =
          from[0] + (to[0] - from[0]) * t + Math.abs(perpY) * offset;
        const lon =
          from[1] + (to[1] - from[1]) * t + perpX * offset;
        pathPoints.push([lat, lon]);
      }

      const trail = L.polyline(pathPoints, {
        color,
        weight: 1,
        opacity: 0.7,
        dashArray: '6 6'
      }).addTo(missileLayer);
      const marker = L.circleMarker(pathPoints[0], {
        radius: 4,
        color,
        fillColor: '#ff9933',
        fillOpacity: 0.9
      }).addTo(missileLayer);
      const start = Date.now();

      return new Promise((resolve) => {
        const timer = setInterval(() => {
          const elapsed = Date.now() - start;
          const t = Math.min(1, elapsed / duration);
          const offset = Math.sin(Math.PI * t) * curveHeight;
          const lat =
            from[0] + (to[0] - from[0]) * t + Math.abs(perpY) * offset;
          const lon =
            from[1] + (to[1] - from[1]) * t + perpX * offset;
          marker.setLatLng([lat, lon]);
          if (t >= 1) {
            clearInterval(timer);
            missileTimers.delete(timer);
            L.circleMarker(to, {
              radius: 8,
              color,
              fillColor: '#ffcc33',
              fillOpacity: 0.4,
              weight: 1
            })
              .addTo(missileLayer)
              .bindTooltip('IMPACT', { permanent: false });
            resolve();
          }
        }, duration / steps);
        missileTimers.add(timer);
      });
    }

    function setTargetMarkers(markers = []) {
      if (!map) initMap();
      if (!targetLayer) targetLayer = L.layerGroup().addTo(map);
      targetLayer.clearLayers();
      markers.forEach((info) => {
        const coords = info.coords || info;
        if (!coords || typeof coords[0] !== 'number' || typeof coords[1] !== 'number') return;
        const highlight = !!info.highlight;
        const marker = L.circleMarker(coords, {
          radius: highlight ? 7 : 5,
          color: highlight ? '#ff3333' : '#55ff88',
          fillColor: highlight ? '#ff6633' : '#33ff66',
          fillOpacity: highlight ? 0.85 : 0.5,
          weight: 2
        });
        if (info.label) {
          marker.bindTooltip(info.label, {
            permanent: highlight,
            direction: 'top'
          });
        }
        targetLayer.addLayer(marker);
      });
    }

    function clearTargetMarkers() {
      if (targetLayer) targetLayer.clearLayers();
    }

    // --- BOOT SEQUENCE --------------------------------------------------------
    function runBootSequence() {
      const lines = [
        'NORAD MAINFRAME LINK ESTABLISHED.',
        'LOADING WOPR STRATEGIC SCENARIO ENGINE...',
        'SCANNING GLOBAL ROUTES........................OK',
        'AUTHENTICATING TERMINAL........................OK',
        'RESOLVING NODE LOCATION........................OK',
        '',
        'SYSTEM ONLINE.',
        ''
      ];

      let idx = 0;
      function next() {
        if (idx < lines.length) {
          appendLine(lines[idx], 'system');
          idx++;
          setTimeout(next, 400);
        } else {
          appendLine('TYPE /HELP TO LIST AVAILABLE COMMANDS.', 'system');
        }
      }
      next();
    }

    // --- GAME MODULE LOADER ---------------------------------------------------
    const gameLoaders = {
      'tic-tac-toe': () => import('/comps/ttt/game.js'),
      chess: () => import('/comps/chess/game.js'),
      checkers: () => import('/comps/checkers/game.js'),
      blackjack: () => import('/comps/blackjack/game.js'),
      solitaire: () => import('/comps/solitare/game.js'),
      gtw: () => import('/comps/gtw/game.js')
    };

    const gameLabels = {
      'tic-tac-toe': 'TIC-TAC-TOE',
      chess: 'CHESS',
      checkers: 'CHECKERS',
      blackjack: 'BLACKJACK',
      solitaire: 'SOLITAIRE',
      gtw: 'GLOBAL THERMONUCLEAR WAR'
    };

    const scenarioAliases = {
      'tic-tac-toe': 'tic-tac-toe',
      tic: 'tic-tac-toe',
      ttt: 'tic-tac-toe',
      chess: 'chess',
      checkers: 'checkers',
      blackjack: 'blackjack',
      'black jack': 'blackjack',
      solitaire: 'solitaire',
      solitare: 'solitaire',
      klondike: 'solitaire',
      'global thermonuclear war': 'gtw',
      gtw: 'gtw'
    };

    function buildGameContext() {
      return {
        appendLine,
        appendCardLine,
        formatCardChunks,
        createBoardElement,
        cardSuitClass,
        clearMissileAnimations,
        animateMissilePath,
        setDefcon,
        setMapView,
        setTargetMarkers,
        clearTargetMarkers,
        exitToTerminal(message) {
          if (message) appendLine(message, 'system');
          currentGame = null;
        }
      };
    }

    async function launchScenario(key) {
      const loader = gameLoaders[key];
      if (!loader) {
        appendLine(`SCENARIO "${key}" NOT AVAILABLE.`, 'warn');
        return;
      }
      try {
        const module = await loader();
        const createGame = module.createGame || module.default;
        if (!createGame) throw new Error('createGame export missing');
        const context = buildGameContext();
        currentGame = createGame(context);
        const label = gameLabels[key] || key.toUpperCase();
        appendLine(`INITIATING SCENARIO: ${label}`, 'system');
        currentGame.start();
      } catch (err) {
        console.error('Failed to load scenario', key, err);
        appendLine('ERROR LOADING SCENARIO. CHECK CONSOLE LOGS.', 'warn');
      }
    }

    // --- CLI COMMANDS ---------------------------------------------------------
    function handleCommand(text) {
      const parts = text.trim().split(/\s+/);
      const cmd = parts[0].toLowerCase();
      const args = parts.slice(1);

      switch (cmd) {
        case '/help':
          appendLine('AVAILABLE COMMANDS:', 'system');
          appendLine('  /help         - SHOW THIS HELP', 'system');
          appendLine('  /chat         - ENTER GLOBAL CHAT', 'system');
          appendLine('  /games        - LIST AVAILABLE WOPR SCENARIOS', 'system');
          appendLine('  /settings     - TERMINAL SETTINGS (PLACEHOLDER)', 'system');
          appendLine('  /defcon N     - SET SIMULATED DEFCON LEVEL (1-5)', 'system');
          appendLine('  /LAUNCH <NAME> - START A GAME (E.G. /LAUNCH TIC-TAC-TOE)', 'system');
          return true;

        case '/chat':
          appendLine('ENTERING GLOBAL CHAT CHANNEL...', 'system');
          appendLine('MESSAGES WITHOUT "/" PREFIX WILL BE BROADCAST.', 'system');
          return true;

        case '/games':
          appendLine('AVAILABLE WOPR SCENARIOS:', 'system');
          appendLine('  TIC-TAC-TOE', 'system');
          appendLine('  CHESS', 'system');
          appendLine('  CHECKERS', 'system');
          appendLine('  BLACKJACK', 'system');
          appendLine('  SOLITAIRE', 'system');
          appendLine('  GLOBAL THERMONUCLEAR WAR (SIMULATION)', 'system');
          appendLine('', 'system');
          appendLine('TYPE:  "/LAUNCH <NAME>"  TO START A SCENARIO.', 'system');
          appendLine('EXAMPLE: /LAUNCH TIC-TAC-TOE', 'system');
          return true;

        case '/settings':
          appendLine('TERMINAL SETTINGS (PLACEHOLDER):', 'system');
          appendLine('  - FUTURE: COLOR THEMES, SOUND FX, TEXT SPEED', 'system');
          return true;

        case '/defcon':
          if (args.length === 0) {
            appendLine('USAGE: /defcon N   (1 = NUCLEAR WAR, 5 = PEACE)', 'warn');
            return true;
          }
          const level = parseInt(args[0], 10);
          if (isNaN(level) || level < 1 || level > 5) {
            appendLine('INVALID DEFCON LEVEL. USE 1-5.', 'warn');
            return true;
          }
          setDefcon(level);
          appendLine(`SIMULATION ALERT: DEFCON SET TO ${level}.`, 'system');
          return true;

        case 'launch': // user typed "LAUNCH ..." without slash
        case '/launch':
          const name = args.join(' ').toLowerCase();
          if (!name) {
            appendLine('USAGE: LAUNCH <NAME>. EXAMPLE: LAUNCH TIC-TAC-TOE', 'warn');
            return true;
          }
          const scenarioKey = scenarioAliases[name];
          if (!scenarioKey) {
            appendLine(`SCENARIO "${name.toUpperCase()}" NOT IMPLEMENTED YET.`, 'warn');
            return true;
          }
          launchScenario(scenarioKey);
          return true;

        default:
          appendLine(`UNKNOWN COMMAND: ${cmd}. TYPE /HELP FOR OPTIONS.`, 'warn');
          return true;
      }
    }

    // --- SOCKET HANDLERS ------------------------------------------------------
    socket.on('chat-message', (msg) => {
      const time = new Date(msg.timestamp).toLocaleTimeString();
      const line = `[${time}] ${msg.codename}: ${msg.text}`;
      appendLine(line);
    });

    socket.on('system-message', (text) => {
      appendLine(`*** ${text} ***`, 'system');
    });

    socket.on('user-list', (users) => {
      const count = users.length || 0;
      statusLine.textContent =
        'ACTIVE LINKS: ' + String(count).padStart(2, '0');
      updateMarkers(users);
    });

    // Init map & boot sequence
    window.addEventListener('load', () => {
      initMap();
      setDefcon(5);
      runBootSequence();
    });

    // --- INPUT HANDLING -------------------------------------------------------
    chatForm.addEventListener('submit', (e) => {
      e.preventDefault();
      const text = chatInput.value.trim();
      if (!text) return;

      // If a game is active, send *all* input to it
      if (currentGame) {
        currentGame.handleInput(text);
        chatInput.value = '';
        return;
      }

      // No game: treat "/" as command, else global chat
      if (text.startsWith('/')) {
        handleCommand(text);
      } else {
        socket.emit('chat-message', text);
      }

      chatInput.value = '';
    });
  </script>
</body>
</html>
